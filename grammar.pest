// Grammar for Mokka



// MODULE

module = _{
    (module_item ~ char_newline ~ char_newline)* ~ SOI
}

module_item = {
    import | function | structure
}



// IMPORT

import = {
    import_from_part? ~ import_import_part
}

import_from_part = {
    kwd_from ~ char_space ~ relative_module ~ char_space
}

import_import_part = {
    kwd_import ~ char_space ~
    (name_function | name_struct) ~
    (sep_import ~ char_space ~ (name_function | name_struct))*
}



// FUNCTION

function = {
    function_header ~ char_newline ~ body
}

function_header = {
    (modifiers_function ~ char_space)? ~ kwd_function ~ char_space ~ name_function ~
    list_arguments ~
    (char_space ~ sep_returnvalue ~ char_space ~ name_type)?
    ~ sep_shouldindent
}



// GENERATOR

generator = {
    generator_header ~ char_newline ~ body
}

generator_header = {
    kwd_generator ~ char_space ~ name_generator ~
    list_arguments ~
    (sep_yieldvalue ~ char_space ~ name_type)? ~
    sep_shouldindent
}


// ARGUMENTS

list_arguments = {
    open_arguments ~
    (
    (argument ~ sep_arguments ~ char_space)* ~
	(argument ~ sep_arguments)
	)? ~
    close_arguments
}


argument = {
    name_type ~
    sep_local_type ~
    char_space ~
    name_type
}


// BODY

body = {
    (statement ~ sep_statements)+
}



// STATEMENT

statement = {
    // TODO
}



// DEFINITION OF LOCAL

// TODO

def_local = {
    def_local_typed | def_local_inferred
}

def_local_typed = {
    name_local ~ sep_local_type ~ char_space ~ name_type ~ op_assign_typed
}

def_local_inferred = {
    name_local ~ char_space ~ op_assign_inferred
}



// PARAMETERS

list_parameters = {
    open_parameters ~ 
    (
	(parameter ~ sep_parameters ~ char_space)* ~
	(parameter ~ sep_parameters)
    )? ~
    close_parameters
}

parameter = {
    name_local ~
    char_space ~
    op_assign_inferred ~
    name_local
}



// NAMES

name_local = {
    charset_lower+ ~ (char_underscore ~ charset_lower+)*
}

name_module = {
    charset_lower+ ~ (char_underscore ~ charset_lower+)*
}

name_function = {
    charset_lower ~ (charset_lower | charset_upper)*
}

name_struct = {
    charset_upper ~ (charset_upper | charset_lower)*
}



// MODIFIER

modifiers_binding = { "mutable"? }
modifiers_function = {}



// OPERATORS

op_assign_typed    = { "=" }
op_assign_inferred = { ":=" }

op_binary_subtract = { "-" }
op_binary_add      = { "+" }
op_binary_multiply = { "*" }

op_unary_negate    = { "-" }
op_unary_reference = { "&" }



// SEPARATORS

sep_import        = _{ "," }
sep_parameters    = _{ "," }
sep_arguments     = _{ "," }
sep_local_type    = _{ ":" }
sep_statements    = _{ char_newline }
sep_returnvalue   = _{ "->" }
sep_yieldvalue    = _{ "->" }
sep_shouldindent  = _{ ";" }
sep_relative_module = _{ "." }



// PAIRS

open_parameters  = _{ "(" } 
close_parameters = _{ ")" } 
open_arguments   = _{ "(" }
close_arguments  = _{ ")" }
open_structure   = _{ "{" }
close_structure  = _{ "}" }



// KEYWORDS

kwd_from      = { "from" }
kwd_import    = { "import" }
kwd_function  = { "function" }
kwd_generator = { "generator" }
kwd_structure = { "structure" }
kwd_for       = { "for" }
kwd_in        = { "in" }
kwd_while     = { "while" }
kwd_return    = { "return" }
kwd_yield     = { "yield" }



// CHARACTERSETS

charset_lower = _{ 'a' .. 'z' }
charset_upper = _{ 'A' .. 'Z' }



// CHARACTERS

char_space = _{ " " }
char_newline = _{ "\n" }
char_comment = _{ "#" }
char_underscore = _{ "_" }



// special rules for pest

comment = _{ char_comment ~ (!char_newline ~ ANY)* }

